<!DOCTYPE html>
<html lang="en">

  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-128576866-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-128576866-1');
    </script>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0"/>

    <title>Rest.li architecture user guide</title>
    <meta name="description" content="This document describes how to use Rest.li to build RESTful clients and servers. The first section introduces key architectural elements and provides an over..." />

    <link rel="icon" type="image/png" href="/rest.li/assets/images/icon_pegasus.png">
  
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen,projection" href="/rest.li/assets/css/main.css">
    <link rel="canonical" href="/rest.li/user_guide/server_architecture" />
    <link rel="alternate" type="application/rss+xml" title="rest.li" href="/rest.li/feed.xml" />

    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

    <script src="//code.jquery.com/jquery-3.0.0.min.js"></script>
    <script src="/rest.li/assets/js/search-input.js"></script>
    

    
    <script>
       $(function() {
          $("h1").addClass("no_toc");
       });
    </script>
</head>


  <body>

    <nav class="dark-grey" role="navigation">
    <div class="nav-wrapper container"><a id="logo-container" class="brand-logo" href="/rest.li/">Rest.li</a>
      <ul class="right hide-on-med-and-down">
        
        <li>
          <a href="/rest.li/get_started/quick_start" >
            Getting Started
          </a>
        </li>
        
        <li>
          <a href="/rest.li/user_guide/server_architecture" >
            User Guide
          </a>
        </li>
        
        <li>
          <a href="/rest.li/spec/protocol" >
            API Reference
          </a>
        </li>
        
        <li>
          <a href="/rest.li/contribute/howto" >
            Contribute
          </a>
        </li>
        
          <li>
            <div class="center row" >
              <div class="col s12 ">
                <div class="row">
                  <div class="input-field col s6 s12 min">
                      <i id="search-txt" class="material-icons prefix">search</i>
                      <input type="text" id="search-input">
                    </div>
                  </div>
                </div>
              </div>
          </li>
          <li>
              <a id="github-menu" href="http://github.com/linkedin/rest.li/" >
                   <i class="fa fa-github"></i>
                </a>
          </li>
          </ul>
      <a href="#" data-activates="nav-mobile" class="button-collapse"><i class="material-icons">menu</i></a>
    </div>
</nav>



        <div class="container">
        <div class="row">
                <div class="col s12 m4 l3"> 
               
                    
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">User Guide</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/user_guide/server_architecture">Rest.li Architecture</a></li>
                       
                         <li><a href="/rest.li/user_guide/restli_server">Rest.li Server</a></li>
                       
                         <li><a href="/rest.li/user_guide/restli_client">Rest.li Client Framework</a></li>
                       
                         <li><a href="/rest.li/user_guide/unstructured_data">Unstructured Data</a></li>
                       
                         <li><a href="/rest.li/Components">Components</a></li>
                       
                         <li><a href="/rest.li/Asynchronous-Servers-and-Clients-in-Rest_li">Asynchronous in Rest.li</a></li>
                       
                        </ul>
                     </ul>
                        
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">Data Schemas</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/pdl_schema">PDL Schema</a></li>
                       
                         <li><a href="/rest.li/pdsc_syntax">PDSC Syntax</a></li>
                       
                         <li><a href="/rest.li/pdl_migration">Migrating from PDSC to PDL</a></li>
                       
                         <li><a href="/rest.li/avro_translation">Avro Translation</a></li>
                       
                         <li><a href="/rest.li/java_binding">Java Binding</a></li>
                       
                         <li><a href="/rest.li/annotation_processor">Schema Annotation Processor</a></li>
                       
                        </ul>
                     </ul>
                        
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">Modeling Resources</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/modeling/modeling">Modeling Resources</a></li>
                       
                         <li><a href="/rest.li/modeling/compatibility_check">Snapshots and Resource Compatibility Checking</a></li>
                       
                        </ul>
                     </ul>
                        
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">Data</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/how_data_is_serialized_for_transport">How Data is Serialized for Transport</a></li>
                       
                         <li><a href="/rest.li/how_data_is_represented_in_memory">How Data is Represented in Memory</a></li>
                       
                        </ul>
                     </ul>
                        
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">Main concepts</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/Rest_li-Filters">Filters</a></li>
                       
                         <li><a href="/rest.li/Projections">Projections</a></li>
                       
                         <li><a href="/rest.li/pathspec">PathSpecs</a></li>
                       
                         <li><a href="/rest.li/Validation-in-Rest_li">Validation</a></li>
                       
                         <li><a href="/rest.li/Attachment-Streaming">Attachment Streaming</a></li>
                       
                        </ul>
                     </ul>
                        
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">Mutli-language</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/multi_language_compatibility_matrix">Compatibility Matrix</a></li>
                       
                         <li><a href="/rest.li/test_suite">Test Suite</a></li>
                       
                         <li><a href="https://github.com/mchen07/restli-csharp">C#</a></li>
                       
                         <li><a href="/rest.li/Scala-Integration">Scala Integration</a></li>
                       
                        </ul>
                     </ul>
                        
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">Testing</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/Writing-unit-tests-for-Rest_li-clients-and-servers">Writing Unit Tests</a></li>
                       
                        </ul>
                     </ul>
                        
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">How to</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/Send-Rest_li-Request-Query-In-Request-Body">Send Request Query in the Body</a></li>
                       
                         <li><a href="/rest.li/How-to-use-projections-in-Java">Use Projections</a></li>
                       
                         <li><a href="/rest.li/Rest_li_Avro_conversions">Avro Conversion</a></li>
                       
                         <li><a href="/rest.li/Compression">Compression</a></li>
                       
                         <li><a href="/rest.li/Rest_li-2_x-upgrade-instructions">Migrate to Rest.li 2.x</a></li>
                       
                         <li><a href="/rest.li/testsuite_how_to">Test Suite</a></li>
                       
                         <li><a href="/rest.li/howto_add_new_language">Test Suite - Add New Language</a></li>
                       
                         <li><a href="/rest.li/user_guide/service_errors_java">Configure Service Errors in Java</a></li>
                       
                        </ul>
                     </ul>
                        
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">FAQ</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/Data-FAQ">Rest.li - FAQ</a></li>
                       
                         <li><a href="/rest.li/testsuite_troubleshooting">Test Suite - Troubleshooting</a></li>
                       
                        </ul>
                     </ul>
                        
                    </div>
                     <div class="markdown-body col s12 m3 l9">
                            <h1 id="restli-architecture-user-guide">Rest.li Architecture User Guide</h1>

<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#asynchronous-apis">Asynchronous APIs</a></li>
  <li><a href="#server-data-flow">Server Data Flow</a></li>
  <li><a href="#client-data-flow">Client Data Flow</a></li>
  <li><a href="#development-flow">Development Flow</a></li>
</ul>

<p>This document describes how to use Rest.li to build RESTful clients and
servers. The first section introduces key architectural elements and
provides an overview of the development process. The remainder of the
document serves as a detailed reference to Rest.li features. It is not
necessary to read this entire document before using Rest.li. Once you
understand the basic principles, you can refer to specific sections in
this guide when you have questions. If you just want to get started
exploring a simple sample implementation, see the <a href="/rest.li/start/step_by_step">Tutorial to Create a Server and Client</a>.</p>

<h2 id="introduction">Introduction</h2>

<p>Rest.li is a Java framework that allows you to easily create clients and
servers that use a REST style of communication. Rest.li is based on an
inversion-of-control model. The framework handles most of the data flow
and client/server interaction transparently and calls code you supply at
the appropriate time.</p>

<p>Rest.li allows you to build and access RESTful servers and clients,
without worrying too much about the details of HTTP or JSON. You simply
define a <em>data model</em> (using a schema definition language) and
<em>resources</em> (Java classes that supply or act on the appropriate data in
response to HTTP requests), and Rest.li takes care of everything else.
In this section, we’ll describe the flow of control and data between a
Rest.li server and client. We’ll also look briefly at the development
process, so you understand what tasks you need to do to develop Rest.li
clients and servers, including what Rest.li does for you automatically.</p>

<p>The Rest.li server framework consists of libraries that provide
annotations and helper classes for describing your resources, as well as
an inversion-of-control dispatcher that handles incoming requests and
automatically invokes the appropriate methods in your resources.</p>

<p>The following diagram provides a high-level view of the interaction and
data flow between a Rest.li client and server. The yellow arrows
indicate the flow of requests out of the client and into the server,
while dark blue arrows represent the server’s response. You as a
developer implement the Resource classes in the server. Rest.li provides
the platform code and infrastructure for dispatching and handling
requests. It also generates the Record Templates and RequestBuilder
classes:</p>

<center>
<b>Data and Control Flow Between a Rest.li Server and
Client</b><br /><img src="/rest.li/assets/images/RestLiClientServerFlow.png" />

</center>
<p><a id="wiki-ServerDataFlow"></a></p>

<h2 id="asynchronous-apis">Asynchronous APIs</h2>

<p>Rest.li is built on simple asynchronous APIs. These APIs allow both
servers to run in non-blocking event based frameworks and allow client
code to be written to make non-blocking calls. This approach has a
couple major benefits. On the server, it means that our servers can be
leaner and scale to high request throughput because we don’t need large,
per request, thread pools. On the client, it makes it easy to stitch
together multiple requests to servers in sophisticated flows where
independent calls can be made in parallel.</p>

<p>Rest.li’s client implementation is Netty-based and is designed to work
seamlessly with <a href="https://github.com/linkedin/parseq">ParSeq</a> to
construct complex asynchronous request flows.</p>

<p>There are several server implementations:</p>

<ul>
  <li><a href="/rest.li/Rest_li-with-Servlet-Containers">Servlet</a>
— Battle tested and ready for production use. Containers
supporting <a href="http://download.oracle.com/otndocs/jcp/servlet-3.0-fr-eval-oth-JSpec/">Servlet 3.0
API</a>
are required to benefit from asynchronous, non-blocking request
processing. Jetty 8.x supports Servlet 3.0 and has been used in
large production environments.</li>
  <li><a href="/rest.li/Rest_li-with-Netty">Netty</a>
— Experimental</li>
  <li>Embedded Jetty — Primarily for integration testing as it’s trivial
to spin up as part of a test suite</li>
</ul>

<p>See <a href="/rest.li/user_guide/restli_server#asynchronous-resources">Asynchronous Resources</a> for more details on how to handle requests using non-blocking request processing.</p>

<p>The remainder of this guide will assume use of the servlet server
implementation.</p>

<h2 id="server-data-flow">Server Data Flow</h2>

<p>Starting with the server (on the right in the diagram above), the
following steps occur when a request is submitted to a Rest.li server:</p>

<ul>
  <li>The R2 transport layer receives a request (HTTP + JSON) and sends it
on to Rest.li. (R2 is a separate library that provides HTTP transport
services. It is independent of Rest.li but is included with the Rest.li
code base. It’s designed to work well with Rest.li.)</li>
  <li>Rest.li’s routing logic inspects the request’s URI path and
determines which target <em>resource</em> (a Java class) the server has defined
to handle that request.</li>
  <li>Rest.li parses the request to extract any parameters.</li>
  <li>Rest.li creates a new instance of the resource class designated to
handle the request.</li>
  <li>Rest.li invokes the appropriate methods of the resource object,
passing in any necessary Java parameters.</li>
  <li>The resource object instantiates and returns a response, in the form
of a RecordTemplate object.</li>
  <li>Rest.li serializes the response object and passes it back to the
requesting client through the R2 transport layer.</li>
</ul>

<p>We’ll look at what you, as a developer, need to do to support this data
flow shortly. Although, you probably noticed that Rest.li does most of
the work. The primary task of the developer is to define the data model
to be supported by your server and implement the <em>resource</em> classes that
can produce that data. Rest.li handles the details of routing requests,
instantiating resource classes, and invoking methods on objects at the
right time.</p>

<p>When writing resource classes, it is important to understand that
Rest.li constructs a new instance of the appropriate resource class to
handle each request. This means that resource objects cannot store state
across multiple requests. Any long-lived resources should be managed
separately. See <a href="/rest.li/user_guide/restli_server#dependency-injection">Dependency Injection</a>.</p>

<p><a id="wiki-ClientDataFlow"></a></p>

<h2 id="client-data-flow">Client Data Flow</h2>

<p>Rest.li also provides support for writing clients. Clients issue
requests by instantiating a RequestBuilder object that supports methods
that allow details of the request to be specified. The RequestBuilder
object generates a Request object that can be passed to Rest.li and sent
to the server using the R2 transport layer. When the server responds (as
detailed above), the client receives the request using the R2 transport,
and Rest.li produces a RecordTemplate object (matching the object
instantiated by the server) and provides the object to the client.</p>

<p>Both client and server work with the same Java representations of the
server’s data model. Note that you do not need to use a Rest.li based
client to communicate with a Rest.li server. However, Rest.li supports
type-safe data exchange using Java interfaces when using Rest.li for
both client and server.</p>

<p><a id="wiki-DevelopmentFlow"></a></p>

<h2 id="development-flow">Development Flow</h2>

<p>Next, let’s briefly look at the basic development flow required to
implement a client and server to support the data flow described in the
previous section. Your tasks as a developer are basically to define your
data model using a simple modeling language and to implement Java
classes that act on or produce that data. Rest.li supports these tasks
with a combination of base classes and code generation.</p>

<p>The following diagram illustrates the major steps in building servers
and clients based on the Rest.li framework. The numbers in the diagram
correspond to the sequence in which tasks are done. Blue boxes represent
classes you will write, while green boxes represent components that are
created by Rest.li’s code generators. Black arrows indicate a code
generation process; red dashed lines indicate the use of classes that
allow a server and clients to exchange data.</p>

<center>
<b>Rest.li Development
Flow</b><br /><img src="/rest.li/assets/images/RestLiCodeGen.png" />

</center>
<p>Let’s look at each step:</p>

<ul>
  <li><strong>Step 1</strong>. The first step in building a Rest.li application is to
define your data schema using <a href="/rest.li/pdl_schema">Pegasus Data Schemas</a>.</li>
  <li>In <strong>Step 2</strong>, a Rest.li code generator creates Java classes that
represent the data model defined in Step 1. These RecordTemplate
classes serve as the Java representation of the data in both the
server and client.</li>
  <li><strong>Step 3</strong> is to implement the server Resource classes and define
the operations they support. Rest.li provides a set of annotations
and base classes that allow you to map Resource classes to REST
endpoints and to specify methods of your Resource classes to respond
to REST operations, such as GET or PUT. Your Resource classes are
expected to return data using instances of the RecordTemplate
classes generated in Step 2.</li>
  <li>In <strong>Step 4</strong>, Rest.li generates an interface description (IDL) file
that provides a simple, textual, machine-readable specification of
the server resources implemented in Step 3. The IDL is considered
the source of truth for the interface contract between the server
and its clients. The IDL itself is a language-agnostic JSON format.
Rest.li uses this IDL along with the original data schema files to
support automatically generating human-readable documentation, which
can be requested from a server. See <a href="/rest.li/setup/gradle#compatibility">IDL Compatibility</a>
for build details and how run the IDL check in “backwards” and
“ignore” modes.</li>
  <li><strong>Step 5</strong> is to create your server application, which involves
leveraging a few Rest.li classes to instantiate the Rest.li server,
set up the transport layer, and supply Rest.li with the location
(class path) of your Resource classes.</li>
  <li>In <strong>Step 6</strong>, Rest.li generates classes known as RequestBuilders
that correspond to the server resource classes. These
RequestBuilders are used by clients to create requests to the
server. Together with the RecordTemplate and Resource classes,
RequestBuilders provide convenient and type-safe mechanisms for
working with the data models supported by the server.</li>
  <li>Finally, <strong>Step 7</strong> is to implement one or more clients. Clients
issue requests by instantiating the RequestBuilder classes generated
in Step 6. These RequestBuilders produce Requests that are passed to
Rest.li to issue requests to a server.</li>
</ul>

<p>The <a href="/rest.li/start/step_by_step">Tutorial</a>
provides a step-by-step walk through of this development process and
demonstrates the nuts and bolts, including build scripts and other
infrastructure required to execute these steps.</p>

                     </div>
                   </div>
</div>



      <footer class="page-footer">
    <div class="container">
      <div class="row">
        <div class="col s6">
          <h5>Rest.li</h5>
          <p class="text-lighten-4">Rest.li is an open source REST framework for building robust, scalable RESTful architectures using type-safe bindings and asynchronous, non-blocking IO. Rest.li fills a niche for applying RESTful principles at scale with an end-to-end developer workflow for building REST APIs, which promotes clean REST practices, uniform interface design and consistent data modeling.</p>
        </div>
        <div class="col s5 offset-s1">
          <h5 class="black-text">Community</h5>
          <ul>
              <li>GitHub <a class="" href="https://github.com/linkedin/rest.li">Rest.li</a></li>
              <li>LinkedIn <a class="" href="https://www.linkedin.com/groups/4855943/">Rest.li Group</a></li>
            <li>Follow us on twitter: <a class="" href="https://twitter.com/rest_li"> @rest_li</a></li>
            <li>Issue Tracking: <a class="" href="https://github.com/linkedin/rest.li/issues">GitHub issue tracking</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="footer-copyright">
        <div class="container">
            <div class="row">
              <div class="col s6">
                      Copyright 2018 LinkedIn Corporation </br>
                      This work is licensed under a <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.  </br>
                      For clarity, no trademark is licensed.
                      </br></br>
              </div>
              <div class="col s5 offset-s1">
                      This work was made by using Jekyll (and a Jekyll Starter Template)</br>
                      <a target="_blank" href="https://github.com/macrod68/jekyll-materialize-starter-template">https://github.com/macrod68/jekyll-materialize-starter-template</a></br>
                      Copyright © 2017 Marco Damiani. Powered by <a target="_blank" href="http://jekyllrb.com/">Jekyll</a></br>
                      License:<a target="_blank" href="https://opensource.org/licenses/MIT">MIT</a>
              </div>
            </div>
        </div>
    </div>
    <script>
      $(function() {
        return $("h2, h3, h4, h5, h6").each(function(i, el) {
          var $el, icon, id;
          $el = $(el);
          id = $el.attr('id');
          icon = '<i class="fa fa-link"></i>';
          if (id) {
            return $el.append($("<a />").addClass("header-link").attr("href", "#" + id).html(icon));
          }
        });
      });
      </script>
</footer>

      
    <!--  Scripts-->                                                                               
<script src="/rest.li/assets/js/jquery.min.js"></script>
<script src="/rest.li/assets/js/materialize.min.js"></script>
<script src="/rest.li/assets/js/init.js"></script>

  </body>

</html>
